{"version":3,"file":"Chapter_13/ParticleSystem/CH13_ParticleSystem.html","sources":["./Common/esShader.c","./Common/esUtil.c","./Chapter_13/ParticleSystem/ParticleSystem.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["//\r\n// Book:      OpenGL(R) ES 2.0 Programming Guide\r\n// Authors:   Aaftab Munshi, Dan Ginsburg, Dave Shreiner\r\n// ISBN-10:   0321502795\r\n// ISBN-13:   9780321502797\r\n// Publisher: Addison-Wesley Professional\r\n// URLs:      http://safari.informit.com/9780321563835\r\n//            http://www.opengles-book.com\r\n//\r\n\r\n// ESShader.c\r\n//\r\n//    Utility functions for loading shaders and creating program objects.\r\n//\r\n\r\n///\r\n//  Includes\r\n//\r\n#include \"esUtil.h\"\r\n#include <stdlib.h>\r\n\r\n//////////////////////////////////////////////////////////////////\r\n//\r\n//  Private Functions\r\n//\r\n//\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////\r\n//\r\n//  Public Functions\r\n//\r\n//\r\n\r\n//\r\n///\r\n/// \\brief Load a shader, check for compile errors, print error messages to output log\r\n/// \\param type Type of shader (GL_VERTEX_SHADER or GL_FRAGMENT_SHADER)\r\n/// \\param shaderSrc Shader source string\r\n/// \\return A new shader object on success, 0 on failure\r\n//\r\nGLuint ESUTIL_API esLoadShader ( GLenum type, const char *shaderSrc )\r\n{\r\n   GLuint shader;\r\n   GLint compiled;\r\n   \r\n   // Create the shader object\r\n   shader = glCreateShader ( type );\r\n\r\n   if ( shader == 0 )\r\n   \treturn 0;\r\n\r\n   // Load the shader source\r\n   glShaderSource ( shader, 1, &shaderSrc, NULL );\r\n   \r\n   // Compile the shader\r\n   glCompileShader ( shader );\r\n\r\n   // Check the compile status\r\n   glGetShaderiv ( shader, GL_COMPILE_STATUS, &compiled );\r\n\r\n   if ( !compiled ) \r\n   {\r\n      GLint infoLen = 0;\r\n\r\n      glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &infoLen );\r\n      \r\n      if ( infoLen > 1 )\r\n      {\r\n         char* infoLog = malloc (sizeof(char) * infoLen );\r\n\r\n         glGetShaderInfoLog ( shader, infoLen, NULL, infoLog );\r\n         esLogMessage ( \"Error compiling shader:\\n%s\\n\", infoLog );            \r\n         \r\n         free ( infoLog );\r\n      }\r\n\r\n      glDeleteShader ( shader );\r\n      return 0;\r\n   }\r\n\r\n   return shader;\r\n\r\n}\r\n\r\n\r\n//\r\n///\r\n/// \\brief Load a vertex and fragment shader, create a program object, link program.\r\n//         Errors output to log.\r\n/// \\param vertShaderSrc Vertex shader source code\r\n/// \\param fragShaderSrc Fragment shader source code\r\n/// \\return A new program object linked with the vertex/fragment shader pair, 0 on failure\r\n//\r\nGLuint ESUTIL_API esLoadProgram ( const char *vertShaderSrc, const char *fragShaderSrc )\r\n{\r\n   GLuint vertexShader;\r\n   GLuint fragmentShader;\r\n   GLuint programObject;\r\n   GLint linked;\r\n\r\n   // Load the vertex/fragment shaders\r\n   vertexShader = esLoadShader ( GL_VERTEX_SHADER, vertShaderSrc );\r\n   if ( vertexShader == 0 )\r\n      return 0;\r\n\r\n   fragmentShader = esLoadShader ( GL_FRAGMENT_SHADER, fragShaderSrc );\r\n   if ( fragmentShader == 0 )\r\n   {\r\n      glDeleteShader( vertexShader );\r\n      return 0;\r\n   }\r\n\r\n   // Create the program object\r\n   programObject = glCreateProgram ( );\r\n   \r\n   if ( programObject == 0 )\r\n      return 0;\r\n\r\n   glAttachShader ( programObject, vertexShader );\r\n   glAttachShader ( programObject, fragmentShader );\r\n\r\n   // Link the program\r\n   glLinkProgram ( programObject );\r\n\r\n   // Check the link status\r\n   glGetProgramiv ( programObject, GL_LINK_STATUS, &linked );\r\n\r\n   if ( !linked ) \r\n   {\r\n      GLint infoLen = 0;\r\n\r\n      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &infoLen );\r\n      \r\n      if ( infoLen > 1 )\r\n      {\r\n         char* infoLog = malloc (sizeof(char) * infoLen );\r\n\r\n         glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );\r\n         esLogMessage ( \"Error linking program:\\n%s\\n\", infoLog );            \r\n         \r\n         free ( infoLog );\r\n      }\r\n\r\n      glDeleteProgram ( programObject );\r\n      return 0;\r\n   }\r\n\r\n   // Free up no longer needed shader resources\r\n   glDeleteShader ( vertexShader );\r\n   glDeleteShader ( fragmentShader );\r\n\r\n   return programObject;\r\n}","//\r\n// Book:      OpenGL(R) ES 2.0 Programming Guide\r\n// Authors:   Aaftab Munshi, Dan Ginsburg, Dave Shreiner\r\n// ISBN-10:   0321502795\r\n// ISBN-13:   9780321502797\r\n// Publisher: Addison-Wesley Professional\r\n// URLs:      http://safari.informit.com/9780321563835\r\n//            http://www.opengles-book.com\r\n//\r\n\r\n// ESUtil.c\r\n//\r\n//    A utility library for OpenGL ES.  This library provides a\r\n//    basic common framework for the example applications in the\r\n//    OpenGL ES 2.0 Programming Guide.\r\n//\r\n\r\n///\r\n//  Includes\r\n//\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdarg.h>\r\n#include <sys/time.h>\r\n#include <GLES2/gl2.h>\r\n#include <EGL/egl.h>\r\n#include \"esUtil.h\"\r\n#include \"emscripten.h\"\r\n\r\n#include  <X11/Xlib.h>\r\n#include  <X11/Xatom.h>\r\n#include  <X11/Xutil.h>\r\n\r\n// X11 related local variables\r\nstatic Display *x_display = NULL;\r\n\r\n///\r\n// CreateEGLContext()\r\n//\r\n//    Creates an EGL rendering context and all associated elements\r\n//\r\nEGLBoolean CreateEGLContext ( EGLNativeWindowType hWnd, EGLDisplay* eglDisplay,\r\n                              EGLContext* eglContext, EGLSurface* eglSurface,\r\n                              EGLint attribList[])\r\n{\r\n   EGLint numConfigs;\r\n   EGLint majorVersion;\r\n   EGLint minorVersion;\r\n   EGLDisplay display;\r\n   EGLContext context;\r\n   EGLSurface surface;\r\n   EGLConfig config;\r\n   EGLint contextAttribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE, EGL_NONE };\r\n\r\n   // Get Display\r\n   display = eglGetDisplay((EGLNativeDisplayType)x_display);\r\n   if ( display == EGL_NO_DISPLAY )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n\r\n   // Initialize EGL\r\n   if ( !eglInitialize(display, &majorVersion, &minorVersion) )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n\r\n   // Get configs\r\n   if ( !eglGetConfigs(display, NULL, 0, &numConfigs) )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n\r\n   // Choose config\r\n   if ( !eglChooseConfig(display, attribList, &config, 1, &numConfigs) )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n\r\n   // Create a surface\r\n   surface = eglCreateWindowSurface(display, config, (EGLNativeWindowType)hWnd, NULL);\r\n   if ( surface == EGL_NO_SURFACE )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n\r\n   // Create a GL context\r\n   context = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs );\r\n   if ( context == EGL_NO_CONTEXT )\r\n   {\r\n      return EGL_FALSE;\r\n   }   \r\n   \r\n   // Make the context current\r\n   if ( !eglMakeCurrent(display, surface, surface, context) )\r\n   {\r\n      return EGL_FALSE;\r\n   }\r\n   \r\n   *eglDisplay = display;\r\n   *eglSurface = surface;\r\n   *eglContext = context;\r\n   return EGL_TRUE;\r\n} \r\n\r\n\r\n///\r\n//  WinCreate()\r\n//\r\n//      This function initialized the native X11 display and window for EGL\r\n//\r\nEGLBoolean WinCreate(ESContext *esContext, const char *title)\r\n{\r\n    Window root;\r\n    XSetWindowAttributes swa;\r\n    XSetWindowAttributes  xattr;\r\n    Atom wm_state;\r\n    XWMHints hints;\r\n    XEvent xev;\r\n    EGLConfig ecfg;\r\n    EGLint num_config;\r\n    Window win;\r\n\r\n    /*\r\n     * X11 native display initialization\r\n     */\r\n\r\n    x_display = XOpenDisplay(NULL);\r\n    if ( x_display == NULL )\r\n    {\r\n        return EGL_FALSE;\r\n    }\r\n\r\n    root = DefaultRootWindow(x_display);\r\n\r\n    swa.event_mask  =  ExposureMask | PointerMotionMask | KeyPressMask;\r\n    win = XCreateWindow(\r\n               x_display, root,\r\n               0, 0, esContext->width, esContext->height, 0,\r\n               CopyFromParent, InputOutput,\r\n               CopyFromParent, CWEventMask,\r\n               &swa );\r\n\r\n    xattr.override_redirect = FALSE;\r\n    XChangeWindowAttributes ( x_display, win, CWOverrideRedirect, &xattr );\r\n\r\n    hints.input = TRUE;\r\n    hints.flags = InputHint;\r\n    XSetWMHints(x_display, win, &hints);\r\n\r\n    // make the window visible on the screen\r\n    XMapWindow (x_display, win);\r\n    XStoreName (x_display, win, title);\r\n\r\n    // get identifiers for the provided atom name strings\r\n    wm_state = XInternAtom (x_display, \"_NET_WM_STATE\", FALSE);\r\n\r\n    memset ( &xev, 0, sizeof(xev) );\r\n    xev.type                 = ClientMessage;\r\n    xev.xclient.window       = win;\r\n    xev.xclient.message_type = wm_state;\r\n    xev.xclient.format       = 32;\r\n    xev.xclient.data.l[0]    = 1;\r\n    xev.xclient.data.l[1]    = FALSE;\r\n    XSendEvent (\r\n       x_display,\r\n       DefaultRootWindow ( x_display ),\r\n       FALSE,\r\n       SubstructureNotifyMask,\r\n       &xev );\r\n\r\n    esContext->hWnd = (EGLNativeWindowType) win;\r\n    return EGL_TRUE;\r\n}\r\n\r\n\r\n///\r\n//  userInterrupt()\r\n//\r\n//      Reads from X11 event loop and interrupt program if there is a keypress, or\r\n//      window close action.\r\n//\r\nGLboolean userInterrupt(ESContext *esContext)\r\n{\r\n    XEvent xev;\r\n    KeySym key;\r\n    GLboolean userinterrupt = GL_FALSE;\r\n    char text;\r\n\r\n    // Pump all messages from X server. Keypresses are directed to keyfunc (if defined)\r\n    while ( XPending ( x_display ) )\r\n    {\r\n        XNextEvent( x_display, &xev );\r\n        if ( xev.type == KeyPress )\r\n        {\r\n            if (XLookupString(&xev.xkey,&text,1,&key,0)==1)\r\n            {\r\n                if (esContext->keyFunc != NULL)\r\n                    esContext->keyFunc(esContext, text, 0, 0);\r\n            }\r\n        }\r\n        if ( xev.type == DestroyNotify )\r\n            userinterrupt = GL_TRUE;\r\n    }\r\n    return userinterrupt;\r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////\r\n//\r\n//  Public Functions\r\n//\r\n//\r\n\r\n///\r\n//  esInitContext()\r\n//\r\n//      Initialize ES utility context.  This must be called before calling any other\r\n//      functions.\r\n//\r\nvoid ESUTIL_API esInitContext ( ESContext *esContext )\r\n{\r\n   if ( esContext != NULL )\r\n   {\r\n      memset( esContext, 0, sizeof( ESContext) );\r\n   }\r\n}\r\n\r\n\r\n///\r\n//  esCreateWindow()\r\n//\r\n//      title - name for title bar of window\r\n//      width - width of window to create\r\n//      height - height of window to create\r\n//      flags  - bitwise or of window creation flags \r\n//          ES_WINDOW_ALPHA       - specifies that the framebuffer should have alpha\r\n//          ES_WINDOW_DEPTH       - specifies that a depth buffer should be created\r\n//          ES_WINDOW_STENCIL     - specifies that a stencil buffer should be created\r\n//          ES_WINDOW_MULTISAMPLE - specifies that a multi-sample buffer should be created\r\n//\r\nGLboolean ESUTIL_API esCreateWindow ( ESContext *esContext, const char* title, GLint width, GLint height, GLuint flags )\r\n{\r\n   EGLint attribList[] =\r\n   {\r\n       EGL_RED_SIZE,       5,\r\n       EGL_GREEN_SIZE,     6,\r\n       EGL_BLUE_SIZE,      5,\r\n       EGL_ALPHA_SIZE,     (flags & ES_WINDOW_ALPHA) ? 8 : EGL_DONT_CARE,\r\n       EGL_DEPTH_SIZE,     (flags & ES_WINDOW_DEPTH) ? 8 : EGL_DONT_CARE,\r\n       EGL_STENCIL_SIZE,   (flags & ES_WINDOW_STENCIL) ? 8 : EGL_DONT_CARE,\r\n       EGL_SAMPLE_BUFFERS, (flags & ES_WINDOW_MULTISAMPLE) ? 1 : 0,\r\n       EGL_NONE\r\n   };\r\n   \r\n   if ( esContext == NULL )\r\n   {\r\n      return GL_FALSE;\r\n   }\r\n\r\n   esContext->width = width;\r\n   esContext->height = height;\r\n\r\n   if ( !WinCreate ( esContext, title) )\r\n   {\r\n      return GL_FALSE;\r\n   }\r\n\r\n  \r\n   if ( !CreateEGLContext ( esContext->hWnd,\r\n                            &esContext->eglDisplay,\r\n                            &esContext->eglContext,\r\n                            &esContext->eglSurface,\r\n                            attribList) )\r\n   {\r\n      return GL_FALSE;\r\n   }\r\n   \r\n\r\n   return GL_TRUE;\r\n}\r\n\r\nstruct loop_vars_t\r\n{\r\n    struct timeval t1;\r\n    struct timezone tz;\r\n    float totaltime;\r\n    unsigned int frames;\r\n    ESContext* esContext;\r\n};\r\n\r\nstatic void render ( void *data )\r\n{\r\n    struct loop_vars_t* args = (struct loop_vars_t*) data;\r\n    struct timeval t2;\r\n    float deltatime;\r\n\r\n    gettimeofday(&t2, &args->tz);\r\n    deltatime = (float)(t2.tv_sec - args->t1.tv_sec +\r\n        (t2.tv_usec - args->t1.tv_usec) * 1e-6);\r\n    args->t1 = t2;\r\n\r\n    if (args->esContext->updateFunc != NULL)\r\n        args->esContext->updateFunc(args->esContext, deltatime);\r\n    if (args->esContext->drawFunc != NULL)\r\n        args->esContext->drawFunc(args->esContext);\r\n\r\n    eglSwapBuffers(args->esContext->eglDisplay, args->esContext->eglSurface);\r\n\r\n    args->totaltime += deltatime;\r\n    args->frames++;\r\n    if (args->totaltime >  2.0f)\r\n    {\r\n        printf(\"%4d frames rendered in %1.4f seconds -> FPS=%3.4f\\n\",\r\n            args->frames, args->totaltime, args->frames / args->totaltime);\r\n        args->totaltime -= 2.0f;\r\n        args->frames = 0;\r\n    }\r\n}\r\n\r\n///\r\n//  esMainLoop()\r\n//\r\n//    Start the main loop for the OpenGL ES application\r\n//\r\n\r\nvoid ESUTIL_API esMainLoop ( ESContext *esContext )\r\n{\r\n#ifdef __EMSCRIPTEN__\r\n    struct loop_vars_t args = {0};\r\n    args.totaltime = 0.0f;\r\n    args.frames = 0;\r\n    args.esContext = esContext;\r\n    gettimeofday(&args.t1, &args.tz);\r\n    emscripten_set_main_loop_arg(render, &args, 0, 1);\r\n#else\r\n    struct timeval t1, t2;\r\n    struct timezone tz;\r\n    float deltatime;\r\n    float totaltime = 0.0f;\r\n    unsigned int frames = 0;\r\n\r\n    gettimeofday ( &t1 , &tz );\r\n\r\n    while(userInterrupt(esContext) == GL_FALSE)\r\n    {\r\n        gettimeofday(&t2, &tz);\r\n        deltatime = (float)(t2.tv_sec - t1.tv_sec + (t2.tv_usec - t1.tv_usec) * 1e-6);\r\n        t1 = t2;\r\n\r\n        if (esContext->updateFunc != NULL)\r\n            esContext->updateFunc(esContext, deltatime);\r\n        if (esContext->drawFunc != NULL)\r\n            esContext->drawFunc(esContext);\r\n\r\n        eglSwapBuffers(esContext->eglDisplay, esContext->eglSurface);\r\n\r\n        totaltime += deltatime;\r\n        frames++;\r\n        if (totaltime >  2.0f)\r\n        {\r\n            printf(\"%4d frames rendered in %1.4f seconds -> FPS=%3.4f\\n\", frames, totaltime, frames/totaltime);\r\n            totaltime -= 2.0f;\r\n            frames = 0;\r\n        } \r\n    }\r\n#endif\r\n}\r\n\r\n\r\n///\r\n//  esRegisterDrawFunc()\r\n//\r\nvoid ESUTIL_API esRegisterDrawFunc ( ESContext *esContext, void (ESCALLBACK *drawFunc) (ESContext* ) )\r\n{\r\n   esContext->drawFunc = drawFunc;\r\n}\r\n\r\n\r\n///\r\n//  esRegisterUpdateFunc()\r\n//\r\nvoid ESUTIL_API esRegisterUpdateFunc ( ESContext *esContext, void (ESCALLBACK *updateFunc) ( ESContext*, float ) )\r\n{\r\n   esContext->updateFunc = updateFunc;\r\n}\r\n\r\n\r\n///\r\n//  esRegisterKeyFunc()\r\n//\r\nvoid ESUTIL_API esRegisterKeyFunc ( ESContext *esContext,\r\n                                    void (ESCALLBACK *keyFunc) (ESContext*, unsigned char, int, int ) )\r\n{\r\n   esContext->keyFunc = keyFunc;\r\n}\r\n\r\n\r\n///\r\n// esLogMessage()\r\n//\r\n//    Log an error message to the debug output for the platform\r\n//\r\nvoid ESUTIL_API esLogMessage ( const char *formatStr, ... )\r\n{\r\n    va_list params;\r\n    char buf[BUFSIZ];\r\n\r\n    va_start ( params, formatStr );\r\n    vsprintf ( buf, formatStr, params );\r\n    \r\n    printf ( \"%s\", buf );\r\n    \r\n    va_end ( params );\r\n}\r\n\r\n\r\n///\r\n// esLoadTGA()\r\n//\r\n//    Loads a 24-bit TGA image from a file. This is probably the simplest TGA loader ever.\r\n//    Does not support loading of compressed TGAs nor TGAa with alpha channel. But for the\r\n//    sake of the examples, this is sufficient.\r\n//\r\n\r\nchar* ESUTIL_API esLoadTGA ( char *fileName, int *width, int *height )\r\n{\r\n    char *buffer = NULL;\r\n    FILE *f;\r\n    unsigned char tgaheader[12];\r\n    unsigned char attributes[6];\r\n    unsigned int imagesize;\r\n\r\n    f = fopen(fileName, \"rb\");\r\n    if(f == NULL) return NULL;\r\n\r\n    if(fread(&tgaheader, sizeof(tgaheader), 1, f) == 0)\r\n    {\r\n        fclose(f);\r\n        return NULL;\r\n    }\r\n\r\n    if(fread(attributes, sizeof(attributes), 1, f) == 0)\r\n    {\r\n        fclose(f);\r\n        return 0;\r\n    }\r\n\r\n    *width = attributes[1] * 256 + attributes[0];\r\n    *height = attributes[3] * 256 + attributes[2];\r\n    imagesize = attributes[4] / 8 * *width * *height;\r\n    buffer = malloc(imagesize);\r\n    if (buffer == NULL)\r\n    {\r\n        fclose(f);\r\n        return 0;\r\n    }\r\n\r\n    if(fread(buffer, 1, imagesize, f) != imagesize)\r\n    {\r\n        free(buffer);\r\n        return NULL;\r\n    }\r\n    fclose(f);\r\n    return buffer;\r\n}\r\n","//\r\n// Book:      OpenGL(R) ES 2.0 Programming Guide\r\n// Authors:   Aaftab Munshi, Dan Ginsburg, Dave Shreiner\r\n// ISBN-10:   0321502795\r\n// ISBN-13:   9780321502797\r\n// Publisher: Addison-Wesley Professional\r\n// URLs:      http://safari.informit.com/9780321563835\r\n//            http://www.opengles-book.com\r\n//\r\n\r\n// ParticleSystem.c\r\n//\r\n//    This is an example that demonstrates rendering a particle system\r\n//    using a vertex shader and point sprites.\r\n//\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include \"esUtil.h\"\r\n\r\n#define NUM_PARTICLES\t1000\r\n#define PARTICLE_SIZE   7\r\n\r\ntypedef struct\r\n{\r\n   // Handle to a program object\r\n   GLuint programObject;\r\n\r\n   // Attribute locations\r\n   GLint  lifetimeLoc;\r\n   GLint  startPositionLoc;\r\n   GLint  endPositionLoc;\r\n   \r\n   // Uniform location\r\n   GLint timeLoc;\r\n   GLint colorLoc;\r\n   GLint centerPositionLoc;\r\n   GLint samplerLoc;\r\n\r\n   // Texture handle\r\n   GLuint textureId;\r\n\r\n   // Particle vertex data\r\n   float particleData[ NUM_PARTICLES * PARTICLE_SIZE ];\r\n\r\n   // Current time\r\n   float time;\r\n\r\n#ifdef __EMSCRIPTEN__\r\n   GLuint vertexObject;\r\n#endif\r\n} UserData;\r\n\r\n///\r\n// Load texture from disk\r\n//\r\nGLuint LoadTexture ( char *fileName )\r\n{\r\n   int width,\r\n       height;\r\n   char *buffer = esLoadTGA ( fileName, &width, &height );\r\n   GLuint texId;\r\n\r\n   if ( buffer == NULL )\r\n   {\r\n      esLogMessage ( \"Error loading (%s) image.\\n\", fileName );\r\n      return 0;\r\n   }\r\n\r\n   glGenTextures ( 1, &texId );\r\n   glBindTexture ( GL_TEXTURE_2D, texId );\r\n\r\n   glTexImage2D ( GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, buffer );\r\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );\r\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );\r\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\r\n   glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\r\n\r\n   free ( buffer );\r\n\r\n   return texId;\r\n}\r\n\r\n\r\n///\r\n// Initialize the shader and program object\r\n//\r\nint Init ( ESContext *esContext )\r\n{\r\n   UserData *userData = esContext->userData;\r\n   int i;\r\n   \r\n   const char* vShaderStr =\r\n      \"uniform float u_time;\t\t                           \\n\"\r\n      \"uniform vec3 u_centerPosition;                       \\n\"\r\n      \"attribute float a_lifetime;                          \\n\"\r\n      \"attribute vec3 a_startPosition;                      \\n\"\r\n      \"attribute vec3 a_endPosition;                        \\n\"\r\n      \"varying float v_lifetime;                            \\n\"\r\n      \"void main()                                          \\n\"\r\n      \"{                                                    \\n\"\r\n      \"  if ( u_time <= a_lifetime )                        \\n\"\r\n      \"  {                                                  \\n\"\r\n      \"    gl_Position.xyz = a_startPosition +              \\n\"\r\n      \"                      (u_time * a_endPosition);      \\n\"\r\n      \"    gl_Position.xyz += u_centerPosition;             \\n\"\r\n      \"    gl_Position.w = 1.0;                             \\n\"\r\n      \"  }                                                  \\n\"\r\n      \"  else                                               \\n\"\r\n      \"     gl_Position = vec4( -1000, -1000, 0, 0 );       \\n\"\r\n      \"  v_lifetime = 1.0 - ( u_time / a_lifetime );        \\n\"\r\n      \"  v_lifetime = clamp ( v_lifetime, 0.0, 1.0 );       \\n\"\r\n      \"  gl_PointSize = ( v_lifetime * v_lifetime ) * 40.0; \\n\"\r\n      \"}\";\r\n      \r\n   const char* fShaderStr =\r\n      \"precision mediump float;                             \\n\"\r\n      \"uniform vec4 u_color;\t\t                           \\n\"\r\n      \"varying float v_lifetime;                            \\n\"\r\n      \"uniform sampler2D s_texture;                         \\n\"\r\n      \"void main()                                          \\n\"\r\n      \"{                                                    \\n\"\r\n      \"  vec4 texColor;                                     \\n\"\r\n      \"  texColor = texture2D( s_texture, gl_PointCoord );  \\n\"\r\n      \"  gl_FragColor = vec4( u_color ) * texColor;         \\n\"\r\n      \"  gl_FragColor.a *= v_lifetime;                      \\n\"\r\n      \"}                                                    \\n\";\r\n\r\n   // Load the shaders and get a linked program object\r\n   userData->programObject = esLoadProgram ( vShaderStr, fShaderStr );\r\n\r\n   // Get the attribute locations\r\n   userData->lifetimeLoc = glGetAttribLocation ( userData->programObject, \"a_lifetime\" );\r\n   userData->startPositionLoc = glGetAttribLocation ( userData->programObject, \"a_startPosition\" );\r\n   userData->endPositionLoc = glGetAttribLocation ( userData->programObject, \"a_endPosition\" );\r\n   \r\n   // Get the uniform locations\r\n   userData->timeLoc = glGetUniformLocation ( userData->programObject, \"u_time\" );\r\n   userData->centerPositionLoc = glGetUniformLocation ( userData->programObject, \"u_centerPosition\" );\r\n   userData->colorLoc = glGetUniformLocation ( userData->programObject, \"u_color\" );\r\n   userData->samplerLoc = glGetUniformLocation ( userData->programObject, \"s_texture\" );\r\n\r\n   glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f );\r\n\r\n   // Fill in particle data array\r\n   srand ( 0 );\r\n   for ( i = 0; i < NUM_PARTICLES; i++ )\r\n   {\r\n      float *particleData = &userData->particleData[i * PARTICLE_SIZE];\r\n   \r\n      // Lifetime of particle\r\n      (*particleData++) = ( (float)(rand() % 10000) / 10000.0f );\r\n\r\n      // End position of particle\r\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\r\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\r\n      (*particleData++) = ( (float)(rand() % 10000) / 5000.0f ) - 1.0f;\r\n\r\n      // Start position of particle\r\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\r\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\r\n      (*particleData++) = ( (float)(rand() % 10000) / 40000.0f ) - 0.125f;\r\n\r\n   }\r\n\r\n   // Initialize time to cause reset on first update\r\n   userData->time = 1.0f;\r\n\r\n#ifdef __EMSCRIPTEN__\r\n   glGenBuffers(1, &userData->vertexObject);\r\n   glBindBuffer(GL_ARRAY_BUFFER, userData->vertexObject);\r\n   glBufferData(GL_ARRAY_BUFFER, NUM_PARTICLES * PARTICLE_SIZE * 4,\r\n       userData->particleData, GL_STATIC_DRAW);\r\n#endif\r\n\r\n   userData->textureId = LoadTexture ( \"./Chapter_13/ParticleSystem/smoke.tga\" );\r\n   if ( userData->textureId <= 0 )\r\n   {\r\n      return FALSE;\r\n   }\r\n   \r\n   // Use the program object\r\n   glUseProgram ( userData->programObject );\r\n\r\n   return TRUE;\r\n}\r\n\r\n///\r\n//  Update time-based variables\r\n//\r\nvoid Update ( ESContext *esContext, float deltaTime )\r\n{\r\n   UserData *userData = esContext->userData;\r\n  \r\n   userData->time += deltaTime;\r\n\r\n   if ( userData->time >= 1.0f )\r\n   {\r\n      float centerPos[3];\r\n      float color[4];\r\n\r\n      userData->time = 0.0f;\r\n\r\n      // Pick a new start location and color\r\n      centerPos[0] = ( (float)(rand() % 10000) / 10000.0f ) - 0.5f;\r\n      centerPos[1] = ( (float)(rand() % 10000) / 10000.0f ) - 0.5f;\r\n      centerPos[2] = ( (float)(rand() % 10000) / 10000.0f ) - 0.5f;\r\n      \r\n      glUniform3fv ( userData->centerPositionLoc, 1, &centerPos[0] );\r\n\r\n      // Random color\r\n      color[0] = ( (float)(rand() % 10000) / 20000.0f ) + 0.5f;\r\n      color[1] = ( (float)(rand() % 10000) / 20000.0f ) + 0.5f;\r\n      color[2] = ( (float)(rand() % 10000) / 20000.0f ) + 0.5f;\r\n      color[3] = 0.5;\r\n\r\n      glUniform4fv ( userData->colorLoc, 1, &color[0] );\r\n   }\r\n\r\n   // Load uniform time variable\r\n   glUniform1f ( userData->timeLoc, userData->time );\r\n}\r\n\r\n///\r\n// Draw a triangle using the shader pair created in Init()\r\n//\r\nvoid Draw ( ESContext *esContext )\r\n{\r\n   UserData *userData = esContext->userData;\r\n      \r\n   // Set the viewport\r\n   glViewport ( 0, 0, esContext->width, esContext->height );\r\n   \r\n   // Clear the color buffer\r\n   glClear ( GL_COLOR_BUFFER_BIT );\r\n\r\n   // Load the vertex attributes\r\n#ifdef __EMSCRIPTEN__\r\n   glBindBuffer(GL_ARRAY_BUFFER, userData->vertexObject);\r\n   glVertexAttribPointer(userData->lifetimeLoc, 1, GL_FLOAT, GL_FALSE,\r\n       PARTICLE_SIZE * sizeof(GLfloat), (const GLvoid*) 0);\r\n   glVertexAttribPointer(userData->endPositionLoc, 3, GL_FLOAT, GL_FALSE,\r\n       PARTICLE_SIZE * sizeof(GL_FLOAT), (const GLvoid*) 4);\r\n   glVertexAttribPointer(userData->startPositionLoc, 3, GL_FLOAT, GL_FALSE,\r\n       PARTICLE_SIZE * sizeof(GL_FLOAT), (const GLvoid*) 16);\r\n#else\r\n   glVertexAttribPointer ( userData->lifetimeLoc, 1, GL_FLOAT, \r\n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat), \r\n                           userData->particleData );\r\n   \r\n   glVertexAttribPointer ( userData->endPositionLoc, 3, GL_FLOAT,\r\n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat),\r\n                           &userData->particleData[1] );\r\n\r\n   glVertexAttribPointer ( userData->startPositionLoc, 3, GL_FLOAT,\r\n                           GL_FALSE, PARTICLE_SIZE * sizeof(GLfloat),\r\n                           &userData->particleData[4] );\r\n#endif\r\n   \r\n   glEnableVertexAttribArray ( userData->lifetimeLoc );\r\n   glEnableVertexAttribArray ( userData->endPositionLoc );\r\n   glEnableVertexAttribArray ( userData->startPositionLoc );\r\n   // Blend particles\r\n   glEnable ( GL_BLEND );\r\n   glBlendFunc ( GL_SRC_ALPHA, GL_ONE );\r\n\r\n   // Bind the texture\r\n   glActiveTexture ( GL_TEXTURE0 );\r\n   glBindTexture ( GL_TEXTURE_2D, userData->textureId );\r\n#ifndef __EMSCRIPTEN__\r\n   glEnable ( GL_TEXTURE_2D );\r\n#endif\r\n\r\n   // Set the sampler texture unit to 0\r\n   glUniform1i ( userData->samplerLoc, 0 );\r\n\r\n   glDrawArrays( GL_POINTS, 0, NUM_PARTICLES );\r\n   \r\n   eglSwapBuffers ( esContext->eglDisplay, esContext->eglSurface );\r\n}\r\n\r\n///\r\n// Cleanup\r\n//\r\nvoid ShutDown ( ESContext *esContext )\r\n{\r\n   UserData *userData = esContext->userData;\r\n\r\n   // Delete texture object\r\n   glDeleteTextures ( 1, &userData->textureId );\r\n\r\n   // Delete program object\r\n   glDeleteProgram ( userData->programObject );\r\n}\r\n\r\n\r\nint main ( int argc, char *argv[] )\r\n{\r\n   ESContext esContext;\r\n   UserData  userData;\r\n\r\n   esInitContext ( &esContext );\r\n   esContext.userData = &userData;\r\n\r\n   esCreateWindow ( &esContext, \"ParticleSystem\", 640, 480, ES_WINDOW_RGB );\r\n   \r\n   if ( !Init ( &esContext ) )\r\n      return 0;\r\n\r\n   esRegisterDrawFunc ( &esContext, Draw );\r\n   esRegisterUpdateFunc ( &esContext, Update );\r\n   \r\n   esMainLoop ( &esContext );\r\n\r\n   ShutDown ( &esContext );\r\n}\r\n"]}